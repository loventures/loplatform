/*
 * LO Platform copyright (C) 2007â€“2025 LO Ventures LLC.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package loi.cp.content
package gate

import enumeratum.{ArgonautEnum, Enum, EnumEntry}
import loi.asset.assessment.model.*
import loi.asset.discussion.model.Discussion1
import loi.asset.module.model.Module
import loi.cp.course.CourseAccessService.CourseRights
import loi.cp.reference.EdgePath
import scalaz.std.option.*
import scalaz.syntax.functor.*
import scaloi.data.ListTree
import scaloi.data.ListTree.Node
import scaloi.syntax.hypermonad.*

/** Representation of a gating rule that is generated by some business policy.
  *
  * The policy rule status specifies the maximum gate access that a user may have; it is combined with the other gating
  * rules to establish actual gate status.
  */
object PolicyRule:

  /** Evaluate policy rule access to course contents. This evaluates any additional restrictions to apply to content
    * access.
    *
    * Note that this requires access to the full course contents and not just a branch because decisions are made in the
    * context of siblings.
    *
    * This can be generalised out to a pluggable service once such a need arises.
    */
  def evaluatePolicyRules(contents: CourseContents, rights: CourseRights): Map[EdgePath, Status] =
    if rights.restricted then restrictedLearnerContent(contents).toMap
    else if rights.isTrialLearner then trialLearnerContent(contents.tree.subForest, 2, Nil).toMap
    else Map.empty

  /** Processes the flat content in the course for restricted learners, locking all discussions.
    */
  private def restrictedLearnerContent(
    contents: CourseContents,
  ): List[(EdgePath, Status)] =
    for
      content <- contents.nonRootElements
      if content.asset.is[Discussion1]
    yield content.edgePath -> RestrictedLearnerLocked

  /** Processes the top level content in the course for trial learners, locking all modules but the first few, and
    * marking all other content as read only.
    */
  private def trialLearnerContent(
    topLevelContent: List[ContentTree],
    unlock: Int,
    statuses: List[(EdgePath, Status)]
  ): List[(EdgePath, Status)] =
    topLevelContent match
      case Node(content, subForest) :: tail =>
        content.asset match
          case Module.Asset(_) if unlock > 0 =>
            val descendantAccess =
              subForest
                .hyperFlatten1[ListTree, CourseContent]
                .flatMap(desc => trialLearnerContentStatus(desc).strengthL(desc.edgePath))
            trialLearnerContent(tail, unlock - 1, descendantAccess ::: statuses)
          case Module.Asset(_)               =>
            trialLearnerContent(tail, unlock, (content.edgePath -> TrialLearnerLocked) :: statuses)
          case _                             =>
            trialLearnerContent(tail, unlock, (content.edgePath -> TrialLearnerReadOnly) :: statuses)
      case Nil                              => statuses

  /** Final projects, summative assessments, submission assignments locked, discussions read-only. */
  private def trialLearnerContentStatus(content: CourseContent): Option[Status] =
    PartialFunction.condOpt(content.asset) {
      case Assignment1.Asset(_)                                                         => TrialLearnerReadOnly
      case Assessment.Asset(a) if a.data.assessmentType == AssessmentType.Summative     => TrialLearnerLocked
      case PoolAssessment.Asset(a) if a.data.assessmentType == AssessmentType.Summative => TrialLearnerLocked
      case ObservationAssessment1.Asset(_)                                              => TrialLearnerReadOnly
      case Discussion1.Asset(_)                                                         => TrialLearnerReadOnly
    }

  final val TrialLearnerReadOnly    = Status(GateStatus.ReadOnly, PolicyType.TrialLearner)
  final val TrialLearnerLocked      = Status(GateStatus.Locked, PolicyType.TrialLearner)
  final val RestrictedLearnerLocked = Status(GateStatus.Locked, PolicyType.RestrictedLearner)

  /** An evaluated policy rule that specifies the maximum access a user may have. */
  final case class Status(value: GateStatus, policyType: PolicyType)
end PolicyRule

sealed abstract class PolicyType(override val entryName: String) extends EnumEntry

object PolicyType extends Enum[PolicyType] with ArgonautEnum[PolicyType]:
  override def values: IndexedSeq[PolicyType] = findValues

  case object TrialLearner extends PolicyType("TRIAL_LEARNER")

  case object RestrictedLearner extends PolicyType("RESTRICTED_LEARNER")
