/*
 * LO Platform copyright (C) 2007â€“2025 LO Ventures LLC.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package loi.cp.email

import javax.mail.internet.MimeMultipart
import javax.mail.{Address, Message, Part}

import com.learningobjects.cpxp.controller.upload.UploadInfo
import scaloi.syntax.any.*
import com.learningobjects.cpxp.util.HtmlUtils
import com.learningobjects.de.web.MediaType
import org.apache.commons.io.FileUtils
import org.apache.commons.text.StringEscapeUtils

import scalaz.syntax.std.boolean.*

/** Support for unmarshalling an email message.
  */
object UnmarshalEmailSupport:

  /** Extracts the text body of an email as plaintext.
    * @param part
    *   the email
    * @return
    *   the text body
    */
  def plaintextContent(part: Part): String =
    if isMediaType(MediaType.TEXT_PLAIN)(part) then stringContent(part)
    else if isMediaType(MediaType.TEXT_HTML)(part) then HtmlUtils.toPlaintext(stringContent(part))
    else if isMediaType(MediaType.MULTIPART_ALL)(part) then
      plaintextContent(bestPart(subParts(part.getContent.asInstanceOf[MimeMultipart]), html = false))
    else throw new Exception(s"Unsupported mime type: ${part.getContentType}")

  /** Extracts the text body of an email as HTML.
    * @param part
    *   the email
    * @return
    *   the text body
    */
  def htmlContent(part: Part): String =
    if isMediaType(MediaType.TEXT_PLAIN)(part) then htmlText(stringContent(part))
    else if isMediaType(MediaType.TEXT_HTML)(part) then stringContent(part)
    else if isMediaType(MediaType.MULTIPART_ALL)(part) then
      htmlContent(bestPart(subParts(part.getContent.asInstanceOf[MimeMultipart]), html = true))
    else throw new Exception(s"Unsupported mime type: ${part.getContentType}")

  /** String content of a part.
    * @param part
    *   the part
    * @return
    *   the string content
    */
  private def stringContent(part: Part): String = part.getContent.asInstanceOf[String]

  /** Strip autogenerated email addresses from the text.
    * @param text
    *   the text
    * @param domain
    *   the reply domain
    * @return
    *   the stripped text
    */
  def stripReplyEmailAddresses(text: String, domain: Option[String]): String =
    domain.fold(text) { d =>
      text.replaceAll(s"[a-zA-Z0-9]+\\Q@$d\\E", "")
    }

  /** Extracts the attachment parts of an email.
    * @param part
    *   the email
    * @return
    *   the email attachments
    */
  def attachmentFiles(part: Part): Seq[UploadInfo] =
    // this logic is probably only partially correct. really we ought to also include inline
    // attachments so html bodies with embedded images etc still work.
    if isMediaType(MediaType.MULTIPART_ALL)(part) then
      subParts(part.getContent.asInstanceOf[MimeMultipart]) flatMap attachmentFiles
    else
      (Option(part.getDisposition).filter(_.equalsIgnoreCase(Part.ATTACHMENT)) map { _ =>
        UploadInfo.tempFile(Option(part.getFileName).getOrElse("unknown")) <| { upload =>
          FileUtils.copyInputStreamToFile(part.getInputStream, upload.getFile) // autocloses
        }
      }).toSeq

  /** Converts plaintext to HTML.
    * @param plain
    *   the plaintext
    * @return
    *   the HTML form
    */
  def htmlText(plain: String): String =
    StringEscapeUtils.escapeHtml4(plain).linesIterator.mkString("<br />")

  /** Returns the best text body of an email. This is the one most likely to contain the email body. This is used to
    * inexpertly extract HTML from an email.
    * @param parts
    *   the email
    * @param html
    *   whether to prefer html
    * @return
    *   the best part
    */
  def bestPart(parts: Seq[Part], html: Boolean): Part = // do better...
    parts
      .find(isMediaType(MediaType.MULTIPART_ALTERNATIVE))
      .orElse(parts.find(isTextPart(html)))
      .orElse(parts.find(isTextPart(!html)))
      .getOrElse(parts.head)

  /** Test whether a part is a text part.
    * @param html
    *   whether to test for html or plaintext
    * @param part
    *   the part to test
    * @return
    *   whether it is the expected type
    */
  private def isTextPart(html: Boolean)(part: Part): Boolean =
    !Option(part.getDisposition).contains(Part.ATTACHMENT) &&
      isMediaType(html.fold(MediaType.TEXT_HTML, MediaType.TEXT_PLAIN))(part)

  /** Extracts the parts of a multipart message.
    * @param multipart
    *   the multipart message
    * @return
    *   the parts
    */
  def subParts(multipart: MimeMultipart): Seq[Part] =
    (0 until multipart.getCount) map multipart.getBodyPart

  /** Test whether a MIME part matches a media type.
    * @param mediaType
    *   the media type
    * @param part
    *   the MIME part
    * @return
    *   whether the media type matches
    */
  def isMediaType(mediaType: MediaType)(part: Part): Boolean =
    Option(part.getContentType).exists(mediaType.includes)

  /** Pimps messages to work around nully apis.
    */
  implicit class MessageOps(message: Message):

    /** Get an optional header.
      * @param header
      *   the header name
      * @return
      *   the header value
      */
    def headerOpt(header: String): Option[String] =
      Option(message.getHeader(header)).flatMap(_.headOption)

    /** Get the from address.
      * @return
      *   the from address
      */
    def from: String =
      Option(message.getFrom).fold("<>")(_.mkString)

    /** Get the reply-to address.
      * @return
      *   the reply-to address
      */
    def replyTo: Option[Address] =
      Option(message.getReplyTo).flatMap(_.headOption).orElse(Option(message.getFrom).flatMap(_.headOption))
  end MessageOps
end UnmarshalEmailSupport
