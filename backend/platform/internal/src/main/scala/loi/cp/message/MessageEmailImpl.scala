/*
 * LO Platform copyright (C) 2007â€“2025 LO Ventures LLC.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package loi.cp.message

import javax.mail.internet.MimeMessage
import com.learningobjects.cpxp.component.{ComponentInstance, ComponentService}
import com.learningobjects.cpxp.component.annotation.Component
import com.learningobjects.cpxp.scala.cpxp.Component.*
import com.learningobjects.cpxp.scala.cpxp.Facade.*
import com.learningobjects.cpxp.scala.util.I18nMessage
import com.learningobjects.cpxp.scala.util.Misc.ErrorMessage
import com.learningobjects.cpxp.service.Current
import com.learningobjects.cpxp.service.attachment.AttachmentWebService
import com.learningobjects.cpxp.service.facade.FacadeService
import com.learningobjects.cpxp.service.mime.MimeWebService
import com.learningobjects.cpxp.service.query.QueryService
import loi.cp.context.CourseContextComponent
import loi.cp.email.MarshalEmailSupport.*
import loi.cp.email.UnmarshalEmailSupport.*
import loi.cp.email.*
import loi.cp.reply.ReplyService
import loi.cp.user.UserComponent

import scala.jdk.CollectionConverters.*
import scalaz.\/
import scalaz.syntax.either.*
import scalaz.syntax.std.boolean.*
import scalaz.syntax.std.option.*

/** Email that is generated by an internal message.
  */
@Component
class MessageEmailImpl(
  val self: EmailFacade,
  val componentInstance: ComponentInstance,
  implicit val replyService: ReplyService,
  implicit val fs: FacadeService,
  implicit val qs: QueryService,
  implicit val aws: AttachmentWebService,
  implicit val mws: MimeWebService,
  ms: MessageService
)(implicit cs: ComponentService)
    extends AbstractEmail[Message]
    with MessageEmail:
  import MessageEmailImpl.*

  // This deliberately has instance scope because the attachments must persist until the email is sent
  // which corresponds with the lifetime of an instance of this class.
  implicit val attacher: AttachmentAttacher = new AttachmentAttacher()
  override val bodyClass: Class[Nothing]    = classOf[Nothing]

  override def buildEmail(email: MimeMessage): Unit =
    implicit val cd = componentInstance.getComponent
    val recipient   = getUserId
    val storage     = getMessage.getStorage
    val sender      = storage.getSender.component[UserComponent]
    val context     = storage.getContext map (_.component[CourseContextComponent])
    val footerMsg   = context.fold(FooterInNoContext)(_ => FooterInSomeContext)
    val variables   = List("recipient" -> recipient, "sender" -> sender, "domain" -> Current.getDomainDTO) ++ context
      .map("course" -> _)
    val footer      = footerMsg.i18n(variables)
    val content     = s"<html><body>${storage.getBody}<footer><hr />$footer</footer></body></html>"

    initEmail(email, sender.getFullName, storage.getSubject, storage.getTimestamp)

    email `setContent` contentPart(content, asHtml = true, storage.getAttachments.asScala.toSeq*)

    // if this message is a reply
    storage.getInReplyTo.map(_.facade[MessageStorageFacade]) foreach { inReplyTo =>
      addInReplyTo(
        email,
        (inReplyTo.getSender == recipient)
          .option(inReplyTo.getId), // if this user sent the parent, look for their message id
        recipient
          .facade[MessageParentFacade]
          .findMessageByStorage(inReplyTo.getId)
          .map(_.getId)
      ) // else find the parent message to the user
    }
  end buildEmail

  override def processReply(email: MimeMessage): ErrorMessage \/ Option[Long] =
    val storage = getMessage.getStorage
    val sent    = ms.sendMessage(newMessage(email, storage.getSender), Some(storage.getId), emailCopy = false)
    sent.getStorageId.some.right

  private def newMessage(email: MimeMessage, recipient: Long): NewMessage =
    NewMessage(List(UserRecipient(recipient)), None, email.getSubject, replyContent(email), attachmentFiles(email))

  private def getMessage: MessageFacade =
    getEntity.get.facade[MessageFacade]
end MessageEmailImpl

object MessageEmailImpl:
  final val FooterInNoContext =
    I18nMessage(
      "EMAIL_FOOTER_FROM_USER_html",
      """Sent by {sender.fullName} from <a href="https://{domain.hostName}/">{domain.name}</a>."""
    )

  final val FooterInSomeContext = I18nMessage(
    "EMAIL_FOOTER_FROM_USER_IN_COURSE_html",
    """Sent by {sender.fullName} in {course.name} ({course.courseId}) from <a href="https://{domain.hostName}/">{domain.name}</a>."""
  )
end MessageEmailImpl
